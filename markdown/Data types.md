
# Типы данных

- [Типы данных](#типы-данных)
  - [Стандартные типы](#стандартные-типы)
  - [Статическая типизация](#статическая-типизация)
  - [Константные переменные](#константные-переменные)
    - [const](#const)
    - [constexpr](#constexpr)
  - [Преобразование типов](#преобразование-типов)
    - [static_cast](#static_cast)
      - [Пример 1: Числа](#пример-1-числа)
      - [Пример 2: Строки, символы и числа](#пример-2-строки-символы-и-числа)
    - [reinterpret_cast](#reinterpret_cast)
  - [Динамическая типизация и RTTI](#динамическая-типизация-и-rtti)
    - [dynamic_cast](#dynamic_cast)
    - [typeid](#typeid)
  - [Сноски](#сноски)

## Стандартные типы

Все типы данных в языке C++ можно разделить на две группы: стандартные и пользовательские. Стандартные типы данных включают в себя типы данных, которые уже встроены в язык, и не требуют дополнительных действий для их использования. Пользовательские типы данных, в свою очередь, требуют дополнительных действий для их использования, так как они не встроены в язык. В этом разделе мы рассмотрим стандартные типы данных.

Вот список наиболее часто используемых типов и их краткий обзор:

- `bool` - булевый тип, который может принимать значения `true` или `false`.
- `char` - символьный тип, который может принимать значения от `-128` до `127`.
- `int` - целочисленный тип, который может принимать значения от `-2147483648` до `2147483647`.
- `float` - тип с плавающей точкой, который может принимать значения от `1.2E-38` до `3.4E+38`.
- `double` - тип с плавающей точкой, который может принимать значения от `2.3E-308` до `1.7E+308`.
- `void` - пустой тип, который не может принимать значения.
- `string` - строковый тип, который может принимать значения в виде последовательности символов (Строки в C++ являются объектами, а не примитивными типами данных, но их стоило упомянуть в этом списке, так как они используются очень часто).

## Статическая типизация

В языке C++ типы данных являются статическими. Это означает, что типы данных должны быть известны на этапе компиляции. Это позволяет компилятору выполнять проверки на этапе компиляции, что позволяет избежать ошибок во время выполнения программы.

Для использования статической типизации в C++ используется ключевое слово `auto`[^1]. Это ключевое слово позволяет компилятору самому определить тип переменной на основе значения, которое ей присваивается.

Пример использования `auto`:

```cpp
auto a = 5; // a имеет тип int
auto b = 5.5; // b имеет тип double
auto c = "Hello"; // c имеет тип const char*
```

## Константные переменные

В языке C++ существует два типа константных переменных: `const` и `constexpr`.

### const

Переменная, объявленная с помощью ключевого слова `const`, является константной. Это означает, что ее значение нельзя изменить после ее инициализации.

Пример использования `const`:

```cpp
const int a = 5; // a является константной переменной
a = 6; // Ошибка: нельзя изменять значение константной переменной
```

### constexpr

Переменная, объявленная с помощью ключевого слова `constexpr`, является константной и может быть вычислена во время компиляции. Это означает, что ее значение должно быть известно на этапе компиляции.

Пример использования `constexpr`:

```cpp
constexpr int a = 5; // a является константной переменной
a = 6; // Ошибка: нельзя изменять значение константной переменной
```

## Преобразование типов

В языке C++ существует два типа преобразования типов: преобразование с помощью `static_cast` и преобразование с помощью `reinterpret_cast`.

### static_cast

Преобразование с помощью `static_cast` позволяет преобразовать один тип данных в другой. Это преобразование выполняется во время компиляции.

Пример использования `static_cast`:

```cpp
int a = 5;
double b = static_cast<double>(a); // b имеет тип double
```

#### Пример 1: Числа

```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 5;
    double b = 10.5;
    cout << static_cast<double>(a) / b << endl; // 0,4761904762
    return 0;
```

#### Пример 2: Строки, символы и числа

```cpp
#include <iostream>
using namespace std;

int main() {
    char a = 'a';

    int b = static_cast<int>(a); // b = 97
    cout << b << endl;

    int c = 98;
    char d = static_cast<char>(c); // d = 'b'
    cout << d << endl;

    string e = "Hello";
    char f = static_cast<char>(e[0]); // f = 'H'
    cout << f << endl;

    return 0;
}
```

### reinterpret_cast

Преобразование с помощью `reinterpret_cast` позволяет так же преобразовать один тип данных в другой. Это преобразование выполняется во время выполнения программы.

Пример использования `reinterpret_cast`:

```cpp
int a = 5;
double b = reinterpret_cast<double&>(a); // b имеет тип double
```

Символ `&` в примере выше используется для того, чтобы получить ссылку[^2] на переменную `a`. Это необходимо для того, чтобы `reinterpret_cast` мог преобразовать тип `int` в тип `double`, так как `reinterpret_cast` может преобразовывать только ссылки.

Еще одним ключевым отличием `static_cast` от `reinterpret_cast` является то, что `static_cast` выполняется во время компиляции, а `reinterpret_cast` во время выполнения программы. Кроме того, `static_cast` выполняет проверку типов, а `reinterpret_cast` нет, и поэтому `reinterpret_cast` может привести к ошибкам.

## Динамическая типизация и RTTI

RTTI - это сокращение от `Runtime Type Information`. Это механизм, который позволяет получить информацию о типе объекта во время выполнения программы (Так же это назвается интроспекцией).

В языке C++ существует два типа динамической типизации: `dynamic_cast` и `typeid`.

### dynamic_cast

`dynamic_cast` - это оператор, который позволяет привести объект к другому типу. Он используется для приведения объектов, которые являются наследниками друг друга.

Пример использования `dynamic_cast` с наследованием[^3]:

```cpp
class Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {
public:
    virtual ~Derived() {}
};

int main() {
    Base* b = new Derived();
    Derived* d = dynamic_cast<Derived*>(b);
    delete b;
    return 0;
}
```

Класс `Base` является базовым классом для класса `Derived`. Переменная `b` является указателем на объект класса `Base`. Переменная `d` является указателем на объект класса `Derived`. Мы можем привести переменную `b` к типу `Derived` с помощью оператора `dynamic_cast`. Это возможно, так как класс `Derived` является наследником класса `Base`. Преобразование происходит посредством проверки типа объекта, на который указывает указатель. Если тип объекта совпадает с типом, к которому мы приводим, то преобразование происходит успешно. В противном случае, если тип объекта не совпадает с типом, к которому мы приводим, то преобразование не происходит и возвращается `nullptr` (О чем отдельно будет говорится в теме про указатели).

### typeid

`typeid` - это оператор, который позволяет получить информацию о типе объекта. Он используется для получения информации о типе объекта, который передается в качестве аргумента.

Пример использования `typeid`:

```cpp
class Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {
public:
    virtual ~Derived() {}
};  

int main() {
    Base* b = new Derived();
    std::cout << typeid(*b).name() << std::endl; // выведет Derived
    delete b;
    return 0;
}
```

В данном примере мы создаем объект класса `Derived` и приводим его к типу `Base`. После этого мы получаем информацию о типе объекта, на который указывает указатель `b` с помощью оператора `typeid`. Выводим имя типа объекта, на который указывает указатель `b` с помощью метода `name()`. Выводимое имя типа объекта зависит от компилятора. Например, в случае с компилятором `g++` имя типа объекта будет выведено как `class Derived`.

## Сноски

[^1]: Использование ключевого слова `auto` является не лучшим стилем программирования. Использование ключевого слова `auto` может привести к трудноуловимым ошибкам. Подробнее об этом можно прочитать в статье [C++ Core Guidelines: ES.31: Don’t use auto when type can be deduced](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-auto).

[^2]: Ссылки - это отдельная тема, которая будет рассмотрена в следующий раз.

[^3]: Наследование - один из краеурольных камней ООП, куда пока что лезть рано, но для примера было необходимо.
