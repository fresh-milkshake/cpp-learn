
# Функции

- [Функции](#функции)
  - [Обычные функции](#обычные-функции)
  - [Перегрузка](#перегрузка)
  - [Перегрузка стандартных операторов](#перегрузка-стандартных-операторов)
  - [Перегрузка операторов присваивания](#перегрузка-операторов-присваивания)
    - [Пример 1: Перегрузка операторов инкремента и декремента](#пример-1-перегрузка-операторов-инкремента-и-декремента)
    - [Пример 2: Перегрузка операторов ввода и вывода](#пример-2-перегрузка-операторов-ввода-и-вывода)
  - [lambda](#lambda)
    - [Пример 1: увеличение числа a на b](#пример-1-увеличение-числа-a-на-b)
    - [Пример 2: Сортировка по возрастанию](#пример-2-сортировка-по-возрастанию)
  - [Сноски](#сноски)

## Обычные функции

Функция в языке C++ это некоторый блок кода, который может быть вызван из другого места программы. Функция может принимать аргументы, а так же возвращать значение. Все функции в C++ имеют тип возвращаемого значения, даже если оно не указано явно. В таком случае тип возвращаемого значения будет `void`.

```cpp
void print(int a) {
    print(a);
}
```

- `void` - тип возвращаемого значения функции `print`
- `print` - имя функции
- `(int a)` - аргументы функции
- `{ print(a); }` - тело функции

Сигнатура функции - это её имя и типы аргументов. Например, сигнатура функции `print` выше будет выглядеть так: `print(int)`. Сигнатура функции должна быть уникальной в пределах одного файла. То есть, если в одном файле определена функция `print(int)`, то в этом же файле нельзя определить ещё одну функцию с такой же сигнатурой.

Точка входа в программу - функция `main`. Она должна быть объявлена в глобальной области видимости[^1] [^2] и возвращать значение типа `int`. Возвращаемое значение `main` будет использоваться как код завершения программы.

```cpp
int main() {
    return 0;
}
```

## Перегрузка

Функции могут быть перегружены, то есть иметь одинаковое имя, но разные сигнатуры. При этом, в зависимости от типов аргументов, будет вызвана нужная функция.

```cpp
void print(int a) {
    print(a);
}

void print(float a) {
    print(a);
}

void print(double a) {
    print(a);
}
```

## Перегрузка стандартных операторов

Перегрузка стандартных операторов для различных типов/структур/классов. Например, для структуры `Point` можно перегрузить оператор `+` так, чтобы он складывал координаты точек.

```cpp
struct Point {
    int x, y;
};

Point operator+(Point a, Point b) {
    return {a.x + b.x, a.y + b.y};
}

int main() {
    Point a = {1, 2};
    Point b = {3, 4};
    Point c = a + b; // c = {4, 6}
    return 0;
}
```

Или, вот еще пример, но в этот раз для встроенного типа `int`.

```cpp
int operator+(int a, int b) {
    return a - b;
}

int main() {
    int a = 1;
    int b = 2;
    int c = a + b; // c = -1
    return 0;
}
```

## Перегрузка операторов присваивания

Синтаксис перегрузки операторов:

`тип operator=(тип a, тип b) { ... }`

- `тип` - тип, для которого перегружается оператор
- `operator` - ключевое слово `operator` обозначает, что это перегрузка оператора
- `=` - символ оператора, который перегружается, в данном случае это `=` (может быть любой другой оператор, например `+`, `-`, `*` и т.д.)
- `a` - первый операнд
- `b` - второй операнд

Например, для структуры `Point` можно перегрузить оператор `=` так, чтобы он копировал координаты точки.

```cpp
struct Point {
    int x, y;
};

Point& operator=(Point& a, Point& b) {
    a.x = b.x;
    a.y = b.y;
    return a;
}

int main() {
    Point a = {1, 2};
    Point b = {3, 4};
    a = b; // a = {3, 4}
    return 0;
}
```

Знак `&` в сигнатуре функции означает, что функция принимает ссылку на объект, а не сам объект. Это нужно, чтобы функция могла изменять объект, на который ссылается аргумент. То распространяется и на возвращаемое значение, в этом случае возвращается ссылка, потому что ???функция должна вернуть объект, на который ссылается аргумент???.

### Пример 1: Перегрузка операторов инкремента и декремента

```cpp
struct Point {
    int x, y;
};

Point& operator++(Point& a) {
    a.x++;
    a.y++;
    return a;
}

Point& operator--(Point& a) {
    a.x--;
    a.y--;
    return a;
}

int main() {
    Point a = {1, 2};
    ++a; // a = {2, 3}
    --a; // a = {1, 2}
    return 0;
}
```

### Пример 2: Перегрузка операторов ввода и вывода

```cpp
struct Point {
    int x, y;
};

std::istream& operator>>(std::istream& in, Point& a) {
    in >> a.x >> a.y;
    return in;
}

std::ostream& operator<<(std::ostream& out, Point& a) {
    out << a.x << ' ' << a.y;
    return out;
}

int main() {
    Point a;
    std::cin >> a;
    std::cout << a;
    return 0;
}
```

## lambda

Lambda-функции - это анонимные функции, которые могут быть переданы в качестве аргумента другой функции или возвращены из функции. Они могут быть использованы для передачи функциональности в качестве аргумента, например, в функцию `std::sort`.

Синтаксис lambda-функции: `[] (аргументы) { тело }`. В квадратных скобках указываются захватываемые[^3] переменные, в круглых скобках - аргументы, в фигурных скобках - тело функции.

### Пример 1: увеличение числа a на b

```cpp
int main() {
    int a = 1;
    auto f = [&a] (int b) {
        a += b;
    };
    f(2); // a = 3
    return 0;
}
```

- `[&a]` - захват переменной `a` по ссылке
- `(int b)` - аргумент `b` типа `int`
- `{ a += b; }` - тело функции

### Пример 2: Сортировка по возрастанию

```cpp
#include <algorithm>
#include <iostream>
#include <vector>

int main() {
    std::vector<int> a = {1, 2, 3, 4, 5};
    std::sort(a.begin(), a.end(), [](int x, int y) { return x > y; });
    for (int x : a) {
        std::cout << x << ' ';
    }
    return 0;
}
```

- `[]` - захват переменных не происходит
- `(int x, int y)` - аргументы `x` и `y` типа `int`
- `{ return x > y; }` - тело функции

В примере выше в качестве аргумента функции `std::sort` передается лямбда-функция, которая сравнивает два числа и возвращает `true`, если первое число больше второго.

## Сноски

[^1]: Область видимости - это место, где определена переменная. Все переменные, объявленные внутри функции, видны только внутри этой функции. Так же, переменные, объявленные внутри блока кода, видны только внутри этого блока кода. Например, переменная `a` в функции `print` недоступна вне этой функции. А переменная `b` в блоке `if` недоступна вне этого блока.

[^2]: Глобальная область видимости - это область видимости, в которой объявлены все глобальные переменные и функции. Все остальные области видимости - это локальные области видимости.

[^3]: Захватываемые переменные в lambda-функциях - это переменные, которые используются в теле функции, но не передаются в качестве аргументов. Например, в [примере 1](#пример-1-увеличение-числа-a-на-b) переменная `a` используется в теле функции, но не передается в качестве аргумента. Поэтому она захватывается. В C++11 и C++14 захват переменных по ссылке происходит по умолчанию. В C++17 захват переменных по ссылке происходит только в том случае, если перед именем переменной стоит символ `&`. В [том же примере](#пример-1-увеличение-числа-a-на-b) можно было бы написать `[a]` вместо `[&a]`, но для очевидности было сделано, как сделано.
