
# Современный C++ (По мнению Microsoft)

## Встроенные контейнеры Стандартной Библиотеки

В C++11 были добавлены встроенные контейнеры, которые заменяют старые контейнеры из стандартной библиотеки. Они имеют более удобный интерфейс, и более эффективно работают с памятью. Они также имеют более удобный синтаксис для инициализации.

```cpp
vector<string> apples;
apples.push_back("Granny Smith");
```

Здесь был создан вектор строк, и в него была добавлена строка "Granny Smith". В C++11 можно сделать это так:

```cpp
vector<string> apples = {"Granny Smith"};
```

Или, вот пример с картой:

```cpp
map<string, string> apple_color;
// ...
apple_color["Granny Smith"] = "Green";
```

```cpp
map<string, string> apple_color = {
    {"Granny Smith", "Green"}
};
```

## Алгоритмы Стандартной Библиотеки

В C++11 были добавлены алгоритмы для работы с контейнерами. Они позволяют сделать код более читаемым и понятным.

Код старой библиотеки:

```cpp
vector<int> numbers = {1, 2, 3, 4, 5};
int sum = 0;
for (int i = 0; i < numbers.size(); i++) {
    sum += numbers[i];
}
```

Код новой библиотеки:

```cpp
vector<int> numbers = {1, 2, 3, 4, 5};
int sum = accumulate(numbers.begin(), numbers.end(), 0);
```

Так же, существуют следующие функции:

* `all_of` - возвращает `true`, если все элементы удовлетворяют условию
* `any_of` - возвращает `true`, если хотя бы один элемент удовлетворяет условию
* `none_of` - возвращает `true`, если ни один элемент не удовлетворяет условию
* `for_each` - выполняет функцию для каждого элемента
* `find` - возвращает итератор на первый элемент, который удовлетворяет условию
* `find_if` - возвращает итератор на первый элемент, который удовлетворяет условию
* `find_if_not` - возвращает итератор на первый элемент, который не удовлетворяет условию
* `count` - возвращает количество элементов, которые удовлетворяют условию
* `count_if` - возвращает количество элементов, которые удовлетворяют условию
* и т.д.

## auto вместо явного указания типа

В C++11 появилась возможность не указывать тип переменной, а использовать ключевое слово `auto`:

```cpp
map<int,list<string>>::iterator i = m.begin(); // C-style
auto i = m.begin(); // modern C++
```

## Новый for для работы с контейнерами

В C++11 появился новый `for`, который позволяет работать с контейнерами:

```cpp
vector<int> numbers = {1, 2, 3, 4, 5};
for (auto& number : numbers) {
    number *= 2;
}
```

## constexpr вместо макросов

В C++11 появилась возможность использовать `constexpr`:

```cpp
#define SIZE 10 // C-style
constexpr int size = 10; // modern C++
```

В отличие от макросов, `constexpr` проверяется на этапе компиляции.

## Единая инициализация

В современном C++ можно использовать инициализацию фигурными скобками для любого типа. Эта форма инициализации особенно удобна при инициализации массивов, векторов или других контейнеров. В следующем примере `v2` инициализируется тремя экземплярами `S`. `v3` инициализируется тремя экземплярами `S`, которые сами инициализируются с помощью фигурных скобок. Компилятор выводит тип каждого элемента на основе объявленного типа `v3`.

```cpp
#include <vector>

struct S
{
    std::string name;
    float num;
    S(std::string s, float f) : name(s), num(f) {}
};

int main()
{
    // C-style initialization
    std::vector<S> v;
    S s1("Norah", 2.7);
    S s2("Frank", 3.5);
    S s3("Jeri", 85.9);

    v.push_back(s1);
    v.push_back(s2);
    v.push_back(s3);

    // Modern C++:
    std::vector<S> v2 {s1, s2, s3};

    // or...
    std::vector<S> v3{ {"Norah", 2.7}, {"Frank", 3.5}, {"Jeri", 85.9} };

}
```

## Лямбда-функции

В C-style программировании функцию можно передать другой функции, используя указатель на функцию. Указатели на функции неудобны в поддержке и понимании. Функция, на которую они ссылаются, может быть определена в другом месте исходного кода, далеко от того места, где она вызывается. Кроме того, они не типобезопасны. Современный C++ предоставляет объекты функций, классы, которые переопределяют operator() оператор, который позволяет им вызываться как функция. Самый удобный способ создания объектов функций - это встроенные лямбда-выражения. В следующем примере показано, как использовать лямбда-выражение для передачи объекта функции, который функция find_if будет вызывать для каждого элемента в векторе:

```cpp
    std::vector<int> v {1,2,3,4,5};
    int x = 2;
    int y = 4;
    auto result = find_if(begin(v), end(v), [=](int i) { return i > x && i < y; });
```

Лямбда выражение [=](int i) { return i > x && i < y; } можно прочитать как "функция, которая принимает один аргумент типа int и возвращает логическое значение, указывающее, больше ли аргумент x и меньше ли y". Обратите внимание, что переменные x и y из окружающего контекста можно использовать в лямбда-выражении. Символ [=] указывает, что эти переменные захватываются по значению; другими словами, лямбда-выражение имеет свои собственные копии этих значений.

## Ссылки

* [Modern C++](https://learn.microsoft.com/en-us/cpp/cpp/welcome-back-to-cpp-modern-cpp?view=msvc-170)

## Сноски