
# Name Mangling

- [Name Mangling](#name-mangling)
  - [Что это?](#что-это)
  - [Пример](#пример)

## Что это?

Name Mangling (C++) - это процесс преобразования имени идентификатора в последовательность символов, которая может быть использована в качестве идентификатора C++. Это необходимо для того, чтобы избежать конфликтов имен, когда один и тот же идентификатор может быть использован в разных контекстах.

В C++ есть несколько правил, которые определяют, как имена преобразуются в последовательность символов. Например, если имя начинается с двух подчеркиваний, то это имя преобразуется в `_Z` и на следующем месте идет длина имени, затем идет имя и затем идет нуль-терминатор. Если имя начинается с одного подчеркивания, то это имя преобразуется в `_` и на следующем месте идет имя и затем идет нуль-терминатор. Если имя начинается с символа, то это имя преобразуется в нуль-терминатор и на следующем месте идет имя и затем идет нуль-терминатор.

Например, допустим, у нас есть класс `Foo` с методом `bar` и функция `Foo` с параметром `bar`. В этом случае, если мы попытаемся вызвать `Foo::bar`, компилятор не сможет определить, что мы имеем в виду: класс `Foo` или функция `Foo`. Поэтому, компилятор преобразует их в `_ZN3Foo3barEv` и `_Z3Foov` и теперь компилятор может определить, что мы имеем в виду.

Имя `Foo` преобразуется в `_ZN3Foo3barEv`, потому что оно начинается с символа. `_ZN` означает, что это имя начинается с символа, а `3` означает, что длина имени `Foo` равна 3. Затем идет имя `Foo` и затем идет нуль-терминатор. `3` означает, что длина имени `bar` равна 3. Затем идет имя `bar` и затем идет нуль-терминатор. `E` означает, что это конец имени. `v` означает, что это виртуальный метод, а `E` означает, что это конец имени.

## Пример

В этом примере мы создаем класс `Foo` с методом `bar` и функцию `Foo` с параметром `bar`. Затем мы пытаемся вызвать `Foo::bar` и `Foo` с параметром `bar`.

```cpp
#include <iostream>

class Foo {
public:
    void bar() {
        std::cout << "Foo::bar" << std::endl;
    }
};

void Foo(int bar) {
    std::cout << "Foo" << std::endl;
}

int main() {
    Foo foo;
    foo.bar();

    Foo(5);
    return 0;
}
```

Компилятор преобразует имена `Foo` и `bar` в `_ZN3Foo3barEv` и `_Z3Foov` соответственно. На следующем этапе компилятора, в этом случае это `as` на Linux, он преобразует имена в `_ZN3Foo3barEv` и `_Z3Foov` соответственно.

```asm
_ZN3Foo3barEv:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 16
    mov     rax, qword ptr [rip + .L.str]
    mov     rdi, rax
    call    _ZSt4cout
    mov     rax, qword ptr [rip + .L.str.1]
    ...
```

```asm
_Z3Foov:
    push    rbp
    mov     rbp, rsp
    sub     rsp, 16
    mov     rax, qword ptr [rip + .L.str]
    mov     rdi, rax
    call    _ZSt4cout
    mov     rax, qword ptr [rip + .L.str.1]
    ...
```
