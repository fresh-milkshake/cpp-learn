
# Указатели & ссылки

- [Указатели & ссылки](#указатели--ссылки)
  - [Указатели](#указатели)
    - [Умные указатели](#умные-указатели)
      - [Пример 1](#пример-1)
      - [Пример 2](#пример-2)
  - [Ссылки С++](#ссылки-с)
  - [Модель памяти](#модель-памяти)
    - [Время жизни](#время-жизни)
    - [Стек](#стек)
    - [Куча](#куча)
    - [Статические и глобальные переменные](#статические-и-глобальные-переменные)
  - [Сырые указатели](#сырые-указатели)
    - [Оператор `new`](#оператор-new)
    - [Операор `delete`](#операор-delete)
    - [Утечки памяти](#утечки-памяти)
  - [Сноски](#сноски)

## Указатели

[Указатели](https://ru.wikipedia.org/wiki/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C) - это переменные, которые хранят адрес другой переменной.

```cpp
int a = 5;
int *b = &a;
```

`a` - это переменная, которая хранит значение `5`. `b` - это указатель, который хранит адрес переменной `a`. `&` - это оператор взятия адреса. Он возвращает адрес переменной. `*` - это оператор разыменования. Он возвращает значение переменной, которая хранится по адресу, который хранит указатель.

```cpp
int c = *b;
```

`c` - это переменная, которая хранит значение переменной `a`, которое хранится по адресу, который хранит указатель `b`.

```cpp
int *d = b;
```

`d` - это указатель, который хранит адрес переменной `a`, которая хранится по адресу, который хранит указатель `b`.

### Умные указатели

- `unique_ptr` - это указатель, который может хранить только один адрес. Когда `unique_ptr` выходит из области видимости, он автоматически освобождает память, которую занимает адрес, который он хранит. Если попытаться скопировать `unique_ptr`, то программа завершится с ошибкой.
    > std::unique_ptr is a smart pointer that owns and manages another object through a pointer and disposes of that object when the unique_ptr goes out of scope. (cppreference.com)

- `shared_ptr` - это указатель, который может хранить несколько адресов. Когда `shared_ptr` выходит из области видимости, он автоматически освобождает память, которую занимает адрес, который он хранит, только если он единственный, который хранит этот адрес. Если попытаться скопировать `shared_ptr`, то он будет хранить тот же адрес, что и исходный `shared_ptr`.
    > std::shared_ptr is a smart pointer that retains shared ownership of an object through a pointer. Several shared_ptr objects may own the same object. (cppreference.com)

- `weak_ptr` - это указатель, который может хранить несколько адресов. Когда `weak_ptr` выходит из области видимости, он не освобождает память, которую занимает адрес, который он хранит. Если попытаться скопировать `weak_ptr`, то он будет хранить тот же адрес, что и исходный `weak_ptr`.
    > std::weak_ptr is a smart pointer that holds a non-owning ("weak") reference to an object that is managed by std::shared_ptr. It must be converted to std::shared_ptr in order to access the referenced object. (cppreference.com)

Есть интересный способ использовать умные указатели - это использовать их вместе с контейнерами. Например, если вы хотите хранить несколько объектов в контейнере, то вы можете использовать `shared_ptr` для хранения адресов этих объектов. Тогда, когда вы удаляете объект из контейнера, вы не должны беспокоиться о том, что произойдет с этим объектом, потому что он будет удален автоматически, когда последний `shared_ptr` выйдет из области видимости.

Вот код такого способа:

```cpp
#include <iostream>
#include <memory>
#include <vector>

using namespace std;

class Test {
public:
    Test() {
        cout << "Test constructor" << endl;
    }

    ~Test() {
        cout << "Test destructor" << endl;
    }
};

int main() {
    vector<shared_ptr<Test>> vec;

    vec.push_back(make_shared<Test>());
    vec.push_back(make_shared<Test>());
    vec.push_back(make_shared<Test>());

    return 0;
}
```

В этом коде мы создаем вектор[^1], который хранит `shared_ptr` на объекты класса `Test`. Затем мы добавляем в этот вектор три объекта класса `Test`. Когда мы выходим из области видимости `main`, то все объекты класса `Test` будут удалены автоматически, потому что последний `shared_ptr` вышел из области видимости.

#### Пример 1

```cpp
#include <iostream>
#include <memory>

class A {
public:
    A() {
        std::cout << "A constructor" << std::endl;
    }

    ~A() {
        std::cout << "A destructor" << std::endl;
    }
};

int main() {
    std::unique_ptr<A> a = std::make_unique<A>();
    std::shared_ptr<A> b = std::make_shared<A>();
    std::weak_ptr<A> c = b;

    return 0;
}
```

Вывод программы:

```bash
A constructor
A constructor
A destructor
A destructor
```

Объяснение:

- `a` - это `unique_ptr`, который хранит адрес объекта `A`, который создается внутри `make_unique`. Когда `a` выходит из области видимости, он автоматически освобождает память, которую занимает адрес, который он хранит.
- `b` - это `shared_ptr`, который хранит адрес объекта `A`, который создается внутри `make_shared`. Когда `b` выходит из области видимости, он автоматически освобождает память, которую занимает адрес, который он хранит, только если он единственный, который хранит этот адрес.
- `c` - это `weak_ptr`, который хранит адрес объекта `A`, который создается внутри `make_shared`. Когда `c` выходит из области видимости, он не освобождает память, которую занимает адрес, который он хранит.

#### Пример 2

```cpp
#include <iostream>
#include <memory>

class A {
public:
    A() {
        std::cout << "A constructor" << std::endl;
    }

    ~A() {
        std::cout << "A destructor" << std::endl;
    }
};

int main() {
    std::shared_ptr<A> a = std::make_shared<A>();
    std::shared_ptr<A> b = a;
    std::weak_ptr<A> c = b;

    return 0;
}
```

Вывод программы:

```bash
A constructor
A destructor
```

Объяснение:

- `a` - это `shared_ptr`, который хранит адрес объекта `A`, который создается внутри `make_shared`. Когда `a` выходит из области видимости, он автоматически освобождает память, которую занимает адрес, который он хранит, только если он единственный, который хранит этот адрес.
- `b` - это `shared_ptr`, который хранит адрес объекта `A`, который создается внутри `make_shared`. Когда `b` выходит из области видимости, он автоматически освобождает память, которую занимает адрес, который он хранит, только если он единственный, который хранит этот адрес.
- `c` - это `weak_ptr`, который хранит адрес объекта `A`, который создается внутри `make_shared`. Когда `c` выходит из области видимости, он не освобождает память, которую занимает адрес, который он хранит.

## Ссылки С++

[Ссылки](https://ru.wikipedia.org/wiki/%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B0) - это переменные, которые хранят адрес другой переменной. Альтернатива функциональности указателей.

```cpp
int a = 5;
int &b = a;
```

`a` - это переменная, которая хранит значение `5`. `b` - это ссылка, которая хранит адрес переменной `a`.

```cpp
int c = b;
```

`c` - это переменная, которая хранит значение переменной `a`, которая хранится по адресу, который хранит ссылка `b`.

```cpp
int &d = b;
```

`d` - это ссылка, которая хранит адрес переменной `a`, которая хранится по адресу, который хранит ссылка `b`.

и так далее...

## Модель памяти

Модель памяти - это способ организации памяти в компьютере. Все компьютеры имеют модель памяти, но они могут быть разными. Например, модель памяти x86 и модель памяти ARM.

Например, в модели памяти x86 есть регистры, стек и куча. Регистры - это быстрые переменные, которые хранятся внутри процессора. Стек - это быстрая память, которая хранится внутри процессора. Куча - это медленная память, которая хранится внутри оперативной памяти.

### Время жизни

Время жизни - это время, которое переменная существует. Например, переменная, которая создается внутри функции, существует только внутри функции.

### Стек

Стек - это быстрая память, которая хранится внутри процессора. Стек используется для хранения переменных, которые создаются внутри функции. Когда функция завершается, все переменные, которые создались внутри функции, удаляются из стека.

### Куча

Куча - это медленная память, которая хранится внутри оперативной памяти. Куча используется для хранения переменных, которые создаются вне функции. Когда переменная удаляется из кучи, она не удаляется из памяти, а помечается как свободная. Когда операционная система запускает программу, она выделяет память для кучи. Когда программа завершается, операционная система освобождает память для кучи.

### Статические и глобальные переменные

Статические и глобальные переменные хранятся в куче. Когда программа завершается, операционная система освобождает память для кучи.

## Сырые указатели

Сырые указатели - это указатели, которые не имеют типа. Например, если вы создаете указатель, который указывает на переменную типа `int`, вы должны указать тип `int` в указателе. Например:

```cpp
int* p = new int;
```

В этом примере `p` - это указатель, который указывает на переменную типа `int`. Если вы не указываете тип, вы получите сырой указатель. Например:

```cpp
int* p = new int;
int* p = new;
```

В этом примере `p` - это сырой указатель, который указывает на переменную типа `int`. Если вы используете сырой указатель, вы можете получить ошибку. Например:

```cpp
int* p = new;
*p = 5; // Ошибка, потому что p не указывает на переменную типа int
```

### Оператор `new`

Оператор `new` используется для создания переменной в куче. Например:

```cpp
int* p = new int;
```

В этом примере `p` - это указатель, который указывает на переменную типа `int`.

### Операор `delete`

Оператор `delete` используется для удаления переменной из кучи. Например:

```cpp
int* p = new int;
delete p;
```

После выполнения оператора `delete`, переменная `p` удаляется из кучи.

### Утечки памяти

Утечки памяти - это когда вы создаете переменную в куче, но не удаляете ее. Например:

```cpp
#include <iostream>

int main()
{
    int* p = new int;
    return 0;
}
```

В этом примере переменная `p` создается в куче, но не удаляется. Если вы создаете много переменных в куче, вы можете получить ошибку. Например:

```cpp
#include <iostream>

int main()
{
    for (int i = 0; i < 1000000000; i++)
    {
        int* p = new int;
    }
    return 0;
}
```

В этом примере переменная `p` создается в куче 1 миллиард раз. Если вы запустите эту программу, вы получите ошибку: `std::bad_alloc`.

## Сноски

[^1]: Вектор - это динамический массив, который может изменять свой размер во время выполнения программы.
