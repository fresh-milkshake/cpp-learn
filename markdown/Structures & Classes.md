
# Структуры и классы

- [Структуры и классы](#структуры-и-классы)
  - [ООП](#ооп)
    - [Статический полиморфизм](#статический-полиморфизм)
    - [Динамический полиморфизм](#динамический-полиморфизм)
      - [Виртуальные методы](#виртуальные-методы)
      - [Таблица виртуальных методов](#таблица-виртуальных-методов)
    - [Пример](#пример)
  - [Правило нуля/трех/пяти](#правило-нулятрехпяти)
    - [Правило нуля](#правило-нуля)
    - [Правило трех](#правило-трех)
    - [Правило пяти](#правило-пяти)
  - [Множественное наследование](#множественное-наследование)
    - [Ромбовидное наследование](#ромбовидное-наследование)
  - [Сноски](#сноски)

## ООП

Объектно-ориентированное программирование (ООП) - это парадигма программирования, основанная на понятии объекта, который является экземпляром определенного класса, а класс - это своего рода чертеж, по которому создаются объекты.

Пример класса:

```cpp
class Person {
public:
    std::string name;
    int age;
};
```

Пример объекта:

```cpp
Person p;
p.name = "John";
p.age = 30;
```

Все объекты в C++ являются наследниками класса `Object`, который имеет следующие методы:

```cpp
class Object {
public:
    virtual bool Equals(Object* obj);
    virtual int GetHashCode();
    virtual std::string ToString();
};
```

Метод `Equals` сравнивает объекты по значению, а метод `GetHashCode` возвращает хеш-код объекта. Метод `ToString` возвращает строковое представление объекта.

### Статический полиморфизм

Статический полиморфизм - это возможность вызывать один и тот же метод для разных типов объектов. Особенность в том, что он не может быть реализован при помощи общего базового класса, т.к. это будет уже динамический полиморфизм. Кроме того, его поведение опеределяется на этаапе компиляции.

Пример:

```cpp
class Person {
public:
    std::string name;
    int age;
};

class Student : public Person {
public:
    int course;
};

class Teacher : public Person {
public:
    std::string subject;
};

void PrintName(Person* p) {
    std::cout << p->name << std::endl;
}

int main() {
    Person* p = new Person();
    p->name = "John";
    PrintName(p);

    Student* s = new Student();
    s->name = "Bob";
    PrintName(s);

    Teacher* t = new Teacher();
    t->name = "Alice";
    PrintName(t);
}
```

Вывод:

```cpp
Person: John, 30
Student: Mary, 20, 5
```

### Динамический полиморфизм

Динамический полиморфизм - это возможность вызывать один и тот же метод для разных типов объектов, но во время выполнения программы. Так же он реализуется с помощью виртуальных методов.

Пример[^1]:

```cpp
// Создаем абстрактный класс Shape
class Shape {
public:
    // Чистый виртуальный метод
    virtual void Square() = 0;
};

// Класс Circle наследуется от Shape
class Circle : public Shape {
public:
    int radius;
    void Square() { // Переопределяем метод Square
        std::cout << "Circle square: " << 3.14 * radius * radius << std::endl;
    }
};

// Класс Rectangle наследуется от Shape
class Rectangle : public Shape {
public:
    int width;
    int height;
    void Square() { // Переопределяем метод Square
        std::cout << "Rectangle square: " << width * height << std::endl;
    }
};

int main() {
    // Создаем объекты классов Circle и Rectangle
    Circle c;
    c.radius = 5;
    Rectangle r;
    r.width = 10;
    r.height = 5;

    // Создаем массив указателей на объекты класса Shape
    Shape* shapes[2];
    shapes[0] = &c; // Записываем в массив указатель на объект класса Circle
    shapes[1] = &r; // То же самое для объекта класса Rectangle

    // Вызываем метод Square для каждого объекта
    for (int i = 0; i < 2; i++) {
        shapes[i]->Square();
    }

    return 0;
}
```

Вывод:

```cpp
Circle square: 78.5
Rectangle square: 50
```

#### Виртуальные методы

Виртуальные методы - это методы, которые могут быть переопределены в производных классах. Виртуальные методы объявляются с помощью ключевого слова `virtual`. Пример:

```cpp
class Animal {
public:
    virtual void Voice() {
        std::cout << "Animal voice" << std::endl;
    }
};

class Dog : public Animal {
public:
    void Voice() {
        std::cout << "Woof" << std::endl;
    }
};

class Cat : public Animal {
public:
    void Voice() {
        std::cout << "Meow" << std::endl;
    }
};

int main() {
    Animal* animals[2];
    animals[0] = new Dog();
    animals[1] = new Cat();

    for (int i = 0; i < 2; i++) {
        animals[i]->Voice();
    }

    return 0;
}
```

#### Таблица виртуальных методов

> Таблица виртуальных методов (англ. virtual method table, VMT) — координирующая таблица или vtable — механизм, используемый в языках программирования для поддержки динамического соответствия (или метода позднего связывания).

Допустим, программа содержит несколько классов в иерархии наследования: базовый класс Cat и два подкласса DomesticCat и Lion. Класс Cat определяет виртуальную функцию speak, так что его подклассы могут обеспечивать соответствующую реализацию (т.е. «мяу» или «рык»).

Когда программа вызывает метод speak по указателю Cat (который может указывать на класс Cat или любой подкласс Cat), контекстное окружение (среда запуска) должна уметь определять, какая именно реализация вызывается, в зависимости от текущего типа указываемого объекта.

Существует множество различных способов реализации подобного динамического связывания, но решение при помощи виртуальной таблицы весьма распространено в C++ и родственных языках (как например, D и C#). Языки, в которых есть разделение на программный интерфейс объектов и их реализацию, как Visual Basic и Delphi, также склоняются к использованию аналогов виртуальной таблицы, так как это позволяет объектам использовать другую реализацию просто используя другой набор указателей метода.

### Пример

Рассмотрим следующие объявления класса C++:

```cpp
class B1 {
public:
  void f0() {}
  virtual void f1() {}
  int int_in_b1;
};

class B2 {
public:
  virtual void f2() {}
  int int_in_b2;
};
```

используем для создания следующего класса:

```cpp
class D : public B1, public B2 {
public:
  virtual void f1() {}
  virtual void f2() {} // переопределение
  int int_in_d;
};
```

G++ создает следующую 32-битную таблицу виртуальных методов для объекта `b2`[^2]:

```
b2:
  +0: указатель на ТВМ B2
  +4: значение int_in_b2

ТВМ B2:
  +0: B2::f2()   
```

а для объекта d схема памяти будет такой :

```
d:
  +0: указатель на ТВМ D (для B1)
  +4: значение int_in_b1
  +8: указатель на ТВМ D (для B2)
 +12: значение int_in_b2
 +16: значение int_in_d

Общий размер: 20 байтов.

ТВМ D (для B1):
  +0: B1::f1()  // B1::f1() не переопределён

ТВМ D (для B2):
  +0: D::f2()   // B2::f2() замещён D::f2()
```

Необходимо отметить, что невиртуальные функции (такие как f0) в общем случае не могут появляться в виртуальной таблице, но в некоторых случаях есть исключения (как, например, конструктор по умолчанию).

Переопределение метода `f2()` в классе `D` реализуется дублированием ТВМ `B2` и заменой указателя на `B2::f2()` указателем на `D::f2()`.

## Правило нуля/трех/пяти

Правило нуля/трех/пяти (англ. Rule of zero, three, five) — правило, которое гласит, что для класса, который не использует ресурсы, можно не определять конструктор, деструктор и оператор присваивания. Если класс использует ресурсы, то для него должны быть определены конструкторы, деструктор и оператор присваивания.

Правило нуля/трех/пяти было предложено в 2000 году в статье Herb Sutter «Exceptional C++ Style».

### Правило нуля

Правило нуля гласит, что если класс не использует ресурсы, то для него не нужно определять конструктор, деструктор и оператор присваивания. Это правило применимо к классам, которые не используют динамическую память, не используют внешние ресурсы, не используют виртуальные методы и не имеют виртуальных базовых классов.

### Правило трех

> Правило трёх (также известное как «Закон Большой Тройки» или «Большая Тройка») — правило в C++, гласящее, что если класс или структура определяет один из следующих методов, то они должны явным образом определить все три метода[1]: 
> - Деструктор
>  - Конструктор копирования
>  - Оператор присваивания копированием

### Правило пяти

С выходом одиннадцатого стандарта правило расширилось и стало называться правилом пяти. Теперь при реализации конструктора необходимо реализовать:

* Деструктор
* Конструктор копирования
* Оператор присваивания копированием
* Конструктор перемещения
* Оператор присваивания перемещением

Пример правила пяти:

```cpp
#include <cstring>

class RFive
{
private:
    char* cstring;

public:
    // Конструктор со списком инициализации и телом
    RFive(const char* arg)
    : cstring(new char[std::strlen(arg)+1])
    {
        std::strcpy(cstring, arg);
    }

    // Деструктор
    ~RFive()
    {
        delete[] cstring;
    }

    // Конструктор копирования
    RFive(const RFive& other)
    {
        cstring = new char[std::strlen(other.cstring) + 1];
        std::strcpy(cstring, other.cstring);
    }

    // Конструктор перемещения, noexcept - для оптимизации при использовании стандартных контейнеров
    RFive(RFive&& other) noexcept 
    {
        cstring = other.cstring;
        other.cstring = nullptr;
    }

    // Оператор присваивания копированием (copy assignment)
    RFive& operator=(const RFive& other) 
    {
        if (this == &other)
            return *this;

        char* tmp_cstring = new char[std::strlen(other.cstring) + 1];
        std::strcpy(tmp_cstring, other.cstring);
        delete[] cstring;
        cstring = tmp_cstring;
        return *this;
    }

    // Оператор присваивания перемещением (move assignment)
    RFive& operator=(RFive&& other) noexcept
    {
        if (this == &other)
            return *this;

        delete[] cstring;
        cstring = other.cstring;
        other.cstring = nullptr;
        return *this;
    }

//  Также можно заменить оба оператора присваивания следующим оператором
//  RFive& operator=(RFive other)
//  {
//      std::swap(cstring, other.cstring);
//      return *this;
//  }
};
```

## Множественное наследование

Множественное наследование (англ. multiple inheritance) — свойство языков программирования, позволяющее классу наследовать свойства и методы нескольких родительских классов. В языках программирования, поддерживающих множественное наследование, один класс может наследовать свойства и методы нескольких родительских классов. В языках программирования, не поддерживающих множественное наследование, один класс может наследовать свойства и методы только одного родительского класса.


### Ромбовидное наследование

Ромбовидное наследование (англ. diamond inheritance) — наследование, в котором один класс наследует свойства и методы двух родительских классов, а каждый из родительских классов наследует свойства и методы одного общего родительского класса. В языках программирования, поддерживающих множественное наследование, один класс может наследовать свойства и методы нескольких родительских классов. В языках программирования, не поддерживающих множественное наследование, один класс может наследовать свойства и методы только одного родительского класса.

## Сноски

[^1]: в примере использует виртуальный метод из главы [Виртуальные методы](#Виртуальные-методы)

[^2]: ТВМ - Таблица Виртуальных Методов