
# Структуры и классы

- [Структуры и классы](#структуры-и-классы)
  - [ООП](#ооп)
    - [Статический полиморфизм](#статический-полиморфизм)
    - [Динамический полиморфизм](#динамический-полиморфизм)
      - [Виртуальные методы](#виртуальные-методы)
      - [Таблица виртуальных методов](#таблица-виртуальных-методов)
    - [Пример](#пример)
  - [Правило нуля/трех/пяти](#правило-нулятрехпяти)
  - [Множественное наследование](#множественное-наследование)
    - [Ромбовидное наследование](#ромбовидное-наследование)
  - [Сноски](#сноски)

## ООП

Объектно-ориентированное программирование (ООП) - это парадигма программирования, основанная на понятии объекта, который является экземпляром определенного класса, а класс - это своего рода чертеж, по которому создаются объекты.

Пример класса:

```cpp
class Person {
public:
    std::string name;
    int age;
};
```

Пример объекта:

```cpp
Person p;
p.name = "John";
p.age = 30;
```

Все объекты в C++ являются наследниками класса `Object`, который имеет следующие методы:

```cpp
class Object {
public:
    virtual bool Equals(Object* obj);
    virtual int GetHashCode();
    virtual std::string ToString();
};
```

Метод `Equals` сравнивает объекты по значению, а метод `GetHashCode` возвращает хеш-код объекта. Метод `ToString` возвращает строковое представление объекта.

### Статический полиморфизм

Статический полиморфизм - это возможность вызывать один и тот же метод для разных типов объектов. Особенность в том, что он не может быть реализован при помощи общего базового класса, т.к. это будет уже динамический полиморфизм. Кроме того, его поведение опеределяется на этаапе компиляции.

Пример:

```cpp
class Person {
public:
    std::string name;
    int age;
};

class Student : public Person {
public:
    int course;
};

class Teacher : public Person {
public:
    std::string subject;
};

void PrintName(Person* p) {
    std::cout << p->name << std::endl;
}

int main() {
    Person* p = new Person();
    p->name = "John";
    PrintName(p);

    Student* s = new Student();
    s->name = "Bob";
    PrintName(s);

    Teacher* t = new Teacher();
    t->name = "Alice";
    PrintName(t);
}
```

Вывод:

```cpp
Person: John, 30
Student: Mary, 20, 5
```

### Динамический полиморфизм

Динамический полиморфизм - это возможность вызывать один и тот же метод для разных типов объектов, но во время выполнения программы. Так же он реализуется с помощью виртуальных методов.

Пример[^1]:

```cpp
// Создаем абстрактный класс Shape
class Shape {
public:
    // Чистый виртуальный метод
    virtual void Square() = 0;
};

// Класс Circle наследуется от Shape
class Circle : public Shape {
public:
    int radius;
    void Square() { // Переопределяем метод Square
        std::cout << "Circle square: " << 3.14 * radius * radius << std::endl;
    }
};

// Класс Rectangle наследуется от Shape
class Rectangle : public Shape {
public:
    int width;
    int height;
    void Square() { // Переопределяем метод Square
        std::cout << "Rectangle square: " << width * height << std::endl;
    }
};

int main() {
    // Создаем объекты классов Circle и Rectangle
    Circle c;
    c.radius = 5;
    Rectangle r;
    r.width = 10;
    r.height = 5;

    // Создаем массив указателей на объекты класса Shape
    Shape* shapes[2];
    shapes[0] = &c; // Записываем в массив указатель на объект класса Circle
    shapes[1] = &r; // То же самое для объекта класса Rectangle

    // Вызываем метод Square для каждого объекта
    for (int i = 0; i < 2; i++) {
        shapes[i]->Square();
    }

    return 0;
}
```

Вывод:

```cpp
Circle square: 78.5
Rectangle square: 50
```

#### Виртуальные методы

Виртуальные методы - это методы, которые могут быть переопределены в производных классах. Виртуальные методы объявляются с помощью ключевого слова `virtual`. Пример:

```cpp
class Animal {
public:
    virtual void Voice() {
        std::cout << "Animal voice" << std::endl;
    }
};

class Dog : public Animal {
public:
    void Voice() {
        std::cout << "Woof" << std::endl;
    }
};

class Cat : public Animal {
public:
    void Voice() {
        std::cout << "Meow" << std::endl;
    }
};

int main() {
    Animal* animals[2];
    animals[0] = new Dog();
    animals[1] = new Cat();

    for (int i = 0; i < 2; i++) {
        animals[i]->Voice();
    }

    return 0;
}
```

#### Таблица виртуальных методов

> Таблица виртуальных методов (англ. virtual method table, VMT) — координирующая таблица или vtable — механизм, используемый в языках программирования для поддержки динамического соответствия (или метода позднего связывания).

Допустим, программа содержит несколько классов в иерархии наследования: базовый класс Cat и два подкласса DomesticCat и Lion. Класс Cat определяет виртуальную функцию speak, так что его подклассы могут обеспечивать соответствующую реализацию (т.е. «мяу» или «рык»).

Когда программа вызывает метод speak по указателю Cat (который может указывать на класс Cat или любой подкласс Cat), контекстное окружение (среда запуска) должна уметь определять, какая именно реализация вызывается, в зависимости от текущего типа указываемого объекта.

Существует множество различных способов реализации подобного динамического связывания, но решение при помощи виртуальной таблицы весьма распространено в C++ и родственных языках (как например, D и C#). Языки, в которых есть разделение на программный интерфейс объектов и их реализацию, как Visual Basic и Delphi, также склоняются к использованию аналогов виртуальной таблицы, так как это позволяет объектам использовать другую реализацию просто используя другой набор указателей метода.

### Пример

Рассмотрим следующие объявления класса C++:

```cpp
class B1 {
public:
  void f0() {}
  virtual void f1() {}
  int int_in_b1;
};

class B2 {
public:
  virtual void f2() {}
  int int_in_b2;
};
```

используем для создания следующего класса:

```cpp
class D : public B1, public B2 {
public:
  virtual void f1() {}
  virtual void f2() {} // переопределение
  int int_in_d;
};
```

G++ создает следующую таблицу виртуальных методов для объекта `b2`:

| Offset | Method | Type |  
| --- | --- | --- |  
| 0 | f0 | B1 |  
| 4 | f1 | B1 |  
| 8 | f2 | B2 |  
| 12 | int_in_b1 | B1 |  
| 16 | int_in_b2 | B2 |  
| 20 | int_in_d | D |


## Правило нуля/трех/пяти

## Множественное наследование

### Ромбовидное наследование

## Сноски

[^1]: в примере использует виртуальный метод из главы [Виртуальные методы](#Виртуальные-методы)